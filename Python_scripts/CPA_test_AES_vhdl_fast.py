##This script performs correlation power analysis attack on AES. This attack targets 10th round of AES. Successfull attack reveals 10th round key which can be back propagated to have the original key. 



def inv_shiftrow(reg_fin):
   
    #print reg_fin

    reg_init=[0]*16
    #print reg_init
    for i in range(0,16):
        index=(4*(3-(i%4))+i)%16
        #print index

        reg_init[i]=reg_fin[index]

   
    return reg_init
    

def shiftrow(reg_fin):
   
    #print reg_fin

    reg_init=[0]*16
    #print reg_init
    for i in range(0,16):
        index=(4*(i%4+1)+i)%16
        #print index

        reg_init[i]=reg_fin[index]

   
    return reg_init

def hamming_distance (u,v):
    y=bin(int(u,16) ^ int(v,16))
    y=y[2:]
    #print y
    ly=len(y)
    #print ly
    count=0
    for h in range(0,ly):
        if y[h]=='1':
            count=count+1
            #print i
    return count
    
def randomdata():
    import random
    str1=['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']
    str2=['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']
    str=[]
    random.shuffle(str1)
    random.shuffle(str2)
    for i in range(0,len(str1)):
        str.append(str1[i]+str2[i])

    #print str
    return str


def keyexpansion (kin,rcon):
    Sbox = (
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
            )
    sig0=kin[(15-3):(15-0)+1]
##    print sig0
    sig=sig0[1:4]+sig0[0:1]
##    print sig
    wr=[]
    w0=[]
    w1=[]
    w2=[]
    w3=[]
    for i in range(0,4):
        wr.append(hex(Sbox[int(sig[i],16)]))
##    print wr
    wr_0=hex((int(wr[0],16)^rcon))
    wr[0]=wr_0
##    print wr
    
    
    for i in range(0,4):
        w0.append(hex(int(wr[i],16)^int(kin[i],16)))
        w1.append(hex(int(w0[i],16)^int(kin[i+4],16)))
        w2.append(hex(int(w1[i],16)^int(kin[i+8],16)))
        w3.append(hex(int(w2[i],16)^int(kin[i+12],16)))

##    print w0
##    print w1
##    print w2
##    print w3
##    
    kout=w0+w1+w2+w3 
    return kout
def inv_keyexpansion(kout,rcon):
    Sbox = (
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
            )
    kin=[0]*16
    w0=kout[0:4]
    w1=kout[4:8]
    w2=kout[8:12]
    w3=kout[12:16]
##    print w0
##    print w1
##    print w2
##    print w3
    
    a=[]
    b=[]
    c=[]
    d=[]
    sb=[]
    x=[0]*4
    for i in range(4):
        d.append(hex(int(w2[i],16)^int(w3[i],16)))
        c.append(hex(int(w1[i],16)^int(w2[i],16)))
        b.append(hex(int(w0[i],16)^int(w1[i],16)))
    sig=d[1:4]+d[0:1]
    for i in range(4):
        sb.append(hex(Sbox[int(sig[i],16)]))
    
    sb[0]=hex(int(sb[0],16)^rcon)
##    print d
##    print c
##    print b
    for i in range(4):
        a.append(hex(int(sb[i],16)^int(w0[i],16)))

    kin[0:4]=a
    kin[4:8]=b
    kin[8:12]=c
    kin[12:16]=d
    return kin

Sbox = (
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
            )
Inv_Sbox=(
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
 )


import d2xx
import time
from binascii import unhexlify
from binascii import hexlify
import visa
import numpy
from struct import unpack
import csv
from scipy.stats.stats import pearsonr


rm=visa.ResourceManager()
rm.list_resources()
ins=rm.open_resource('USB0::0x0699::0x0408::C018437::INSTR')


ins.write('DATA:SOU CH1')
ins.write('DATA:WIDTH 1')
ins.write('DATA:ENC RPB')
ins.write('DATA:STOP 10000')

ymult=float(ins.query('WFMPRE:YMULT?'))
yzero=float(ins.query('WFMPRE:YZERO?'))
yoff=float(ins.query('WFMPRE:YOFF?'))
xincr=float(ins.query('WFMPRE:XINCR?'))
#ins.write("ACQ:STATE ON")
#ins.write("ACQ:STOPA SEQ")
#d=d2xx.listDevices()
#print d
h=d2xx.open(0)
#print h
h.setBitMode(0xff,0x40)
h.setUSBParameters(0x10000,0x10000)
h.setLatencyTimer(3)
h.purge()
guess=0


wr_cmd='01'
rd_cmd='00'
##key=['00','01','02','03','04','05','06','07','08','09','0A','0B','0C','0D','0E','0F']
##kin=key
##rconv=['0x01','0x02','0x04','0x08','0x10','0x20','0x40','0x80','0x1b','0x36','0x6c']
#kin
##for j in range(0,10):
##    rcon=int(rconv[j],16)
##    ktemp=keyexpansion(kin,rcon)
##    kin=ktemp
####    print j
####    print ktemp
##print ktemp
##rd_data=[]

#keyguess=['C5','2F','3E','65']
keyguess=[]
for i in range(0,16):
    for j in range(0,16):
        a=hex(i)[2]+hex(j)[2]
        keyguess.append(a)

#print keyguess[0:10]
#keyguess=['C5','2F','3E','65']
##keyguess=['7F']
guessno=len(keyguess)
####for i in range(7,-1,-1):
####    a=hex(7-i)
####    keystring=wr_cmd+'333'+a[2]+key[i*2+0]+key[i*2+1]
####    kstr=unhexlify(keystring)
####    h.write(kstr)
####    #print keystring
####    #time.sleep(.05)
    

rconv=['0x01','0x02','0x04','0x08','0x10','0x20','0x40','0x80','0x1b','0x36','0x6c']

acq_length=10000

set0=[0,0,0] 
i=0
set1=[0,0,0]
sum0=numpy.zeros((3,acq_length))
sum1=numpy.zeros((3,acq_length))
measure=6000
power_hd=numpy.zeros(((16,guessno,measure)))
power=numpy.zeros(measure)
while(i<measure):
    rd_data=[]
    if i%100==0:
        print i
    ins.write("ACQ:STATE ON")
    ins.write("ACQ:STOPA SEQ")
    data=randomdata()
##    data=['00','00','00','00','00','00','00','00','00','00','00','00','00','34','00','12']
    #print data
    #interm=(int(data[15-guess],16))^(int(key[15-guess],16))
    ##        interm=(int(data[15-guess],16))^(int(keyguess[gi],16))
    #print interm
    ##        targetfunc=Sbox[interm]
    ##        targetfunc_binary=bin(targetfunc)
    ##        sz=len(targetfunc_binary)-1
    ##        targetbit=targetfunc_binary[sz] #lsb of target function
    ##        print targetbit
    for ii in range(7,-1,-1):
        a=hex(7-ii)
        datastring=wr_cmd+'222'+a[2]+data[ii*2+0]+data[ii*2+1]
        dstr=unhexlify(datastring)
        h.write(dstr)
        time.sleep(0.02)
##        print datastring
    h.write('\x01\x12\x34\x00\x03')
##    time.sleep(.01)
  
    ins.write('CURV?')
    data=ins.read_raw()
    headerlen=2+int(data[1])
    header=data[:headerlen]
    ADC_wave=data[headerlen:-1]

    ADC_wave=numpy.array(unpack('%sB' %len(ADC_wave), ADC_wave))

    Volts=(ADC_wave-yoff)*ymult+yzero
    TIme=numpy.linspace(0,xincr*len(Volts),num=len(Volts))
    a=numpy.asarray(Volts)
    
    power[i]=max(a[8927:9861])
##    numpy.savetxt('powertracenew'+str(i)+'.csv',a,delimiter=',')

    ##        for ii in range(7,-1,-1):
    ##        a=hex(7-ii)
    target_byte_final=[0]*16
    target_byte_prev=[0]*16
    for f in range(0,8):
        a=hex(f)
        rd_command=rd_cmd+'555'+a[2]
        #print rd_command
        h.write(unhexlify(rd_command))
##        time.sleep(.05)
    
    rd_val=hexlify(h.read(h.getQueueStatus()))
    sz=32-len(rd_val)
##    print sz
    while sz>0:
        rd_val=rd_val+hexlify(h.read(h.getQueueStatus()))
        sz=32-len(rd_val)
        
##        print sz
        #print rd_data
##    rd_data.append(rd_val)
    for f in range(0,8):
        target_byte_final[2*f+1]=hex(int((rd_val[4*f+0]+rd_val[4*f+1]),16))
        target_byte_final[2*f+0]=hex(int((rd_val[4*f+2]+rd_val[4*f+3]),16))
##    rd_command=rd_cmd+'555'+'f'
##    h.write(unhexlify(rd_command))
##    time.sleep(.05)
##    rd_data=hexlify(h.read(h.getQueueStatus()))
##    tar_byte_final[]=hex(int((rd_data[2]+rd_data[3]),16))
##    #print "Ciphter"
    #print target_byte_final
##    rd_command=rd_cmd+'5551'
##    h.write(unhexlify(rd_command))
##    time.sleep(.05)
##    rd_data=hexlify(h.read(h.getQueueStatus()))
##    tar_byte=hex(int((rd_data[2]+rd_data[3]),16))
##    #print tar_byte
    
    #target_byte_initial=inv_shiftrow(target_byte_final)
##    print1=target_byte_final
    
    
    
##    ktemp.reverse()
##    target_byte_prev=[0]*16
##    for j in range(0,16):
##        test=int(target_byte_final[j],16)^int(ktemp[j],16)
##        target_byte_prev[j]=hex(Inv_Sbox[test])
##    target_byte_initial=inv_shiftrow(target_byte_prev)
##    print2=target_byte_initial
##    print1.reverse()
##    print2.reverse()
##    print print1
##    print print2
    #print target_byte_prev
    
####    print rd_data
    #print "cipher text:"
    #print target_byte_final
   
    
    for gi in range(0,guessno):
        for j in range(0,16):
            test=int(target_byte_final[j],16)^int(keyguess[gi],16)
            target_byte_prev[j]=hex(Inv_Sbox[test])
        target_byte_initial=inv_shiftrow(target_byte_prev)
        #print "Intermediate"
        #print tar_byte_prev
        #print "Intermediate:"
        #print target_byte_initial
        #print "hamming distance"
        #print HD
        for j in range(0,16):
            HD=hamming_distance(target_byte_initial[j],target_byte_final[j])
            power_hd[j,gi,i]=HD
       
    i=i+1
##        interm=int(tar_byte,16)^int(keyguess[gi],16)
##        targetfunc=Inv_Sbox[interm]
##        targetfunc_binary=bin(targetfunc)
####        print targetfunc
##        sz=len(targetfunc_binary)-1
##        targetbit=targetfunc_binary[sz]
##        if targetbit=='0':
##            
##        #numpy.savetxt('tracenew0'+str(set0)+'.csv',a,delimiter=',')
##            sum0[gi,:]=sum0[gi,:]+a
##            set0[gi]=set0[gi]+1
##            
##        elif targetbit=='1':
##        #numpy.savetxt('tracenew1'+str(set1)+'.csv',a,delimiter=',')
##            sum1[gi,:]=sum1[gi,:]+a
##            set1[gi]=set1[gi]+1

    #ins.write("ACQ:STATE ON")

    #print i
    #print h.getStatus()

           # if(i/1000>0):
                #print i

    ##      for ii in range(7,-1,-1):
    ##        a=hex(7-ii)
    ##        rd_command=rd_cmd+'555'+a[2]
    ##        h.write(rd_command)
    ##        rd_data.append(hexlify(h.read(h.getQueueStatus())))
    ##        
        
        #print rd_data
##ins.write('DATA:SOU CH3')
##ins.write('CURV?')
##data=ins.read_raw()
##headerlen=2+int(data[1])
##header=data[:headerlen]
##ADC_wave=data[headerlen:-1]
##
##ADC_wave=numpy.array(unpack('%sB' %len(ADC_wave), ADC_wave))
##
##Volts=(ADC_wave-yoff)*ymult+yzero
##TIme=numpy.linspace(0,xincr*len(Volts),num=len(Volts))
##a=numpy.asarray(Volts)
##numpy.savetxt('powertrace_clk'+'.csv',a,delimiter=',')
##
##diff=numpy.zeros((3,acq_length))
##numpy.savetxt('power_org_final'+'.csv',power,delimiter=',')
corr=numpy.zeros((16,guessno))
##madmax=[0]*16
key_resolved=[0]*16
for kk in range(0,16):
    for k in range(0,guessno):
        #diff[k,:]=((sum1[k,:]/set1[k])-(sum0[k,:]/set0[k]))
        #numpy.savetxt('sum_0.csv',sum0,delimiter=',')
        #numpy.savetxt('sum_1.csv',sum1,delimiter=',')
        #numpy.savetxt('power_HD_final'+'_'+'guess'+str(k)+'.csv',power_hd[k,:],delimiter=',')
        r=pearsonr(power,power_hd[kk,k,:])
        #corr.append(abs(r[0]))
        corr[kk,k]=abs(r[0])
    #res=corr[kk,:]
    numpy.savetxt('cpabyte'+str(kk)+'.csv',corr[kk,:],delimiter=',')
    maxdex=numpy.argmax(corr[kk,:])
    key_resolved[kk]=keyguess[maxdex]
#print corr
key_resolved_final=shiftrow(key_resolved)
key_resolved_final.reverse()
print "resolved_key of 10th round:"
print key_resolved_final

for i in range(9,-1,-1):
    rcon=int(rconv[i],16)
    key_test=inv_keyexpansion(key_resolved_final,rcon)
    key_resolved_final=key_test
##maxdex=corr.index(max(corr))
##key_resolved=keyguess[maxdex]
print "Resolved original key:"
print key_test

h.close()



